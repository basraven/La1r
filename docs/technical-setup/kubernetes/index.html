<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Kubernetes"><meta property="og:title" content><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://la1r.com/docs/technical-setup/kubernetes/"><title>Kubernetes | La1r</title><link rel=icon href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/book.min.f5d992effe86d0b2d1087f8dc35cd0f870e6882e896558290ad6503af195ae04.css integrity="sha256-9dmS7/6G0LLRCH+Nw1zQ+HDmiC6JZVgpCtZQOvGVrgQ="><script defer src=/en.search.min.46df9af54328b731b1cfda9170e9d67ef4ff8493f075fc49392174852c088992.js integrity="sha256-Rt+a9UMotzGxz9qRcOnWfvT/hJPwdfxJOSF0hSwIiZI="></script><link rel=alternate type=application/rss+xml href=https://la1r.com/docs/technical-setup/kubernetes/index.xml title=La1r></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://la1r.com/><span class=brand-title>| &nbsp;&nbsp;La1r</span><img src=/svg/lair-icon-dark.svg alt=Logo></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul class=pre-inject-menu><li><strong><a href=/>Introduction</a></strong></li></ul><ul><li><a href=/docs/conceptual-setup/>Conceptual Setup</a><ul><li><a href=/docs/conceptual-setup/event-specifications/>Event Specifications</a><ul></ul></li><li><a href=/docs/conceptual-setup/governance-catalogs/>Governance Catalogs</a><ul></ul></li></ul></li><li><a href=/docs/technical-setup/>Technical Setup</a><ul><li><a href=/docs/technical-setup/data-processing/>Data Processing</a></li><li><a href=/docs/technical-setup/ansible/>Ansible</a><ul></ul></li><li><a href=/docs/technical-setup/kubernetes/ class=active>Kubernetes</a><ul></ul></li><li><a href=/docs/technical-setup/secrets/>Secrets</a><ul></ul></li></ul></li><li><a href=/docs/planning/>Planning</a><ul></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Kubernetes</strong></header><article class=markdown><h1 id=how-we-do-kubernetes-k8s>How we do Kubernetes (k8s)</h1><p>K8s can be implemented in a million different ways. The implementation on La1r follows a few principles:</p><ul><li>K8s should run on bare metal only - it should not be dependent on any cloud resource, this includes function-as-service (FaaS) implementations such as AWS Lambda.</li><li>Vanilla k8s should be used - flavored varients of k8s take some controls away from the sys admin and introduce (sometimes unwanted) abstractions.</li><li>The latest k8s version should be used - this to incentive application of new k8s capabilities</li><li>Templating engines, package managers and operators such as helm are not used - this again takes away a lot of control from the sys admin which takes away the learning experience, thus the fun.</li><li>K8s over bare metal - since the use of k8s incentives portability of applications, the default hosting approach should be on k8s not on the bare metal server itself (for example through Ansible). Only things that really make sense or are directly needed by the cluster itself, such as openvpn, can be implemented directly on the server with Ansible.</li></ul><h2 id=makefile-as-the-operator>Makefile as the operator</h2><p>The way the Kubernetes setup is done should also be properly documented to ensure portability of the setup.
For this reason we document all the steps taken in the <a href=/>Kuberentes Makefile</a>.
This makefile should contain all the steps taken to setup and apply <a href=https://github.com/basraven/la1r/kubernetes>the yaml definitions that can be found in the Git repository</a></p><h2 id=init-with-kubeadm>Init with kubeadm</h2><p>Since we're using vanilla k8s on bare metal but we do not have all the time in the world, the decision was made to use kubeadm to initialize the cluster and manage node cluster and upgrades. Several upgrades were already performed with this which went flawless, even with multi cpu (x86 and arm7) architecture environments.</p><h2 id=network-with-weaveworks>Network with weaveworks</h2><p>Initially the decision was made to use flannel as network provider, since this is a pretty standard choice for many k8s implementations. Unfortunately this gave several networking, performance and upgrading issues over time, especially with our multi cpu architecte environment. After a tool selection process weave works came out best because:</p><ul><li>Substantial performance and stability improvements</li><li>Capable of complex network segregations which flannel was not able to do</li><li>Easy to setup, even if several sources on the way point out the opposite</li><li>Bonus: Weave works supplies a fancy and comprehensive dashboard of your entire network</li></ul><h2 id=node-agnostic-storage-coming-soon>Node agnostic storage (coming soon)</h2><p>Storage is often a difficult topic with k8s bare metal clusters, since the entire aim of k8s is to be independent and decoupled from infrastructure. This is why the current plan is to migrate all storage used by the cluster to a storage abstraction service, creating node agnostic storage facilities everywhere on the k8s cluster. The currently plan is to achieve this with ceph through rook.io, which also is an exception on the non-operator application architecture principle as mentioned earlier</p><h2 id=reverse-proxy-with-dmz-ed-online-exposure>Reverse proxy, with dmz-ed online exposure</h2><p>Traefik is used as reverse proxy for all default traffic, this because it easily integrates with k8s and it provides a fancy dashboard UI, and maybe because I'm traefik 2.0 contributer&mldr;
Here my personal preference is to not follow the custom resource definition (CRD) hype and just use standard ingress objects, also for possible portability reasons if I ever get sick of traefik.</p></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/basraven/la1r/commit/c6ecac335b55e940cdb2d0f6cab089586814efcb title="Last modified by Sebastiaan Raven | Jan 28, 2020" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 28, 2020</span></a></div></div></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#how-we-do-kubernetes-k8s>How we do Kubernetes (k8s)</a><ul><li><a href=#makefile-as-the-operator>Makefile as the operator</a></li><li><a href=#init-with-kubeadm>Init with kubeadm</a></li><li><a href=#network-with-weaveworks>Network with weaveworks</a></li><li><a href=#node-agnostic-storage-coming-soon>Node agnostic storage (coming soon)</a></li><li><a href=#reverse-proxy-with-dmz-ed-online-exposure>Reverse proxy, with dmz-ed online exposure</a></li></ul></li></ul></nav></aside></main></body></html>