<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Deployment Architecture"><meta property="og:title" content><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://la1r.com/docs/technical-architecture/infrastructure-architecture/deployment-architecture/"><title>Deployment Architecture | La1r</title><link rel=icon href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/book.min.9d4a50a3f8215d92699ad8fffed3f7e077b3115be0ead58de83527db7f5ce38c.css integrity="sha256-nUpQo/ghXZJpmtj//tP34HezEVvg6tWN6DUn239c44w="><script defer src=/en.search.min.338c3cd7e07cc90f695bf0bc0ee365e236a2b65c080efd274c7cf07b419c2856.js integrity="sha256-M4w81+B8yQ9pW/C8DuNl4jaitlwIDv0nTHzwe0GcKFY="></script><link rel=alternate type=application/rss+xml href=https://la1r.com/docs/technical-architecture/infrastructure-architecture/deployment-architecture/index.xml title=La1r></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://la1r.com/><span class=brand-title>| &nbsp;&nbsp;La1r</span><img src=/svg/lair-icon-dark.svg alt=Logo></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul class=pre-inject-menu><li><strong><a href=/>La1r</a></strong></li></ul><ul><li><a href=/docs/capability-architecture/>Capability Architecture</a><ul><li><a href=/docs/capability-architecture/event-specifications/>Event Specifications</a><ul></ul></li><li><a href=/docs/capability-architecture/governance-catalogs/>Governance Catalogs</a><ul></ul></li></ul></li><li><a href=/docs/technical-architecture/>Technical Architecture</a><ul><li><a href=/docs/technical-architecture/application-architecture/>Application Architecture</a></li><li><a href=/docs/technical-architecture/data-architecture/>Data Architecture</a><ul></ul></li><li><a href=/docs/technical-architecture/infrastructure-architecture/>Infrastructure Architecture</a><ul><li><a href=/docs/technical-architecture/infrastructure-architecture/deployment-architecture/ class=active>Deployment Architecture</a><ul></ul></li><li><a href=/docs/technical-architecture/infrastructure-architecture/storage-architecture/>Storage Architecture</a><ul></ul></li><li><a href=/docs/technical-architecture/infrastructure-architecture/network-architecture/>Network Architecture</a></li></ul></li><li><a href=/docs/technical-architecture/operations-architecture/>Operations Architecture</a></li><li><a href=/docs/technical-architecture/security-architecture/>Security Architecture</a></li></ul></li><li><a href=/docs/planning/>Planning</a><ul></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Deployment Architecture</strong></header><article class=markdown><h2 id=deployment-architecture>Deployment Architecture</h2><p>Two components are used to setup this architecture:</p><ol><li>Ansible, for bare metal server initialization and bare metal services.</li><li>Kubernetes, for running processes which can be containerized</li></ol><p>The aim is to put as many of the services in Kubernetes, keeping the Ansible footprint as small as possible.
Unfortunately there always needs to be an initial setup script, which is handled by the small footprint of Ansible.
All other services need to run in Kubernetes, to improve portability and manageability.</p><h3 id=ansible---prepare-the-infrastructure-and-bare-metal-services>Ansible - Prepare the infrastructure and bare-metal services</h3><p>Since there&rsquo;s always a need for installing packages on the nodes directly and I don&rsquo;t want to just use a bunch of shell scripts all configuration and applications outside of k8s is deployed with Ansible which are directed by makefiles. Makefiles because I don&rsquo;t want to remember all commands that I need to spin up ansible by heart, Ansible because I want to semi-formalize the steps I take.
The goal here is to document every step, it does not matter how small, into an Ansible Playbook script.
These Ansible scripts can be found on <a href=https://github.com/basraven/la1r/ansible>https://github.com/basraven/la1r/ansible</a></p><h4 id=ansible-tags>Ansible Tags</h4><p>The following tags are used in Ansible:</p><ul><li>helper - Helper scripts for the run itself, e.g. to determine OS</li><li>hostname - Set hostname of server</li><li>reboot - Reboots the machine</li><li>update - Update the package managers</li><li>security - Security related packages and update</li><li>kerberos_client - Install Kerberos (MIT) client and get keys. Server will install if hosts file contains <code>kerberos: server</code> for this server.</li><li>kerberos_server - Install Kerberos (MIT) server and create keys. Server will install if hosts file contains <code>kerberos: server</code> for this server.</li><li>toolbox - Placement of /cicd/ansible/toolbox scripts, used for infrastructure management</li><li>users - Creation of users</li><li>dns_server - Install DNS Server</li><li>docker - Install docker</li><li>nfs_client - Install nfs-client</li><li>nfs_server - Install nfs-server</li><li>openvpn_client - Install openvpn client and place certificate from /credentials</li><li>openvpn_server - Install openvpn server and creates new CA</li><li>create_ovpn_user - Create a new certificate for openvpn,<ul><li>Requires <code>---extra-vars "openvpn_user=someusername"</code></li></ul></li><li>delete_ovpn_user - Create a new certificate for openvpn<ul><li>Requires <code>---extra-vars "openvpn_user=someusername"</code></li></ul></li><li>node_exporter - Install prometheus_node_exporter</li><li>kubernetes_server - Install Kubernetes</li><li>init_kubernetes - Run kubeadm init<ul><li>Optional <code>---extra-vars "kubernetes_cidr=10.244.0.0/16"</code></li></ul></li><li>reset_kubernetes - Reset from changes made by kubeadm init and kubeadm join</li><li>fetch_kubernetes - Fetch the Kubernetes config file and put it in the local folder</li><li>storage_kubernetes - Install packages as prep for the storage provider</li><li>join-kubernetes - Join a kubernetes cluster<ul><li>Requires <code>---extra-vars "kubernetes_master=1.1.1.1"</code></li><li>Requires <code>/credentials/kubernetes/join-token.yaml"</code></li></ul></li></ul><h3 id=ci-with-jenkins>CI with Jenkins</h3><p>A key component of the architecture is that in essence, everything should be able to run <strong>without Jenkins</strong>, just with Ansible and Kubernetes.
Jenkins is used, just to streamline the process.</p><h4 id=jenkins-pipelines>Jenkins Pipelines</h4><p>Jenkins contains the following pipelines:</p><ul><li>Deploy Ansible Assets</li><li>Deploy Kubernetes Assets</li></ul><hr><h3 id=makefiles-as-operators>Makefiles as operators</h3><p>The initial approach was to use makefiles as operators. But this was not scalable, these files became a mess.
This is why Jenkins with Configuration As Code was later introduced.</p><h4 id=contents-of-former-makefiles>Contents of former makefiles</h4><p>Since I want to formalize everything into scripts, there needs to be a way to formalize how to call the different playbook with the appropriate arguments.
This is why the Git repository contains 2 Makefiles. There has been chosen for Makefiles because the way these files are called is extremely predictable <code>make &lt;your command></code>:</p><ul><li><a href=/>Makefile for Ansible</a> - This makefile contains all the Ansible Playbook calls which are made to construct la1r on bare metal</li><li><a href=/>Makefile for Kubernetes</a> - This makefile contains all the used Kubernetes calls to setup the Kubernetes nodes. This also contains node setup scripts such as applying taints.</li></ul></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/basraven/la1r/commit/1858c15f4addfc8eb6236582e158958942a6db57 title="Last modified by Sebastiaan Raven | Aug 16, 2020" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Aug 16, 2020</span></a></div></div></div><aside class="book-toc levels-true fixed"><nav id=TableOfContents><ul><li><ul><li><a href=#deployment-architecture>Deployment Architecture</a><ul><li><a href=#ansible---prepare-the-infrastructure-and-bare-metal-services>Ansible - Prepare the infrastructure and bare-metal services</a></li><li><a href=#ci-with-jenkins>CI with Jenkins</a></li><li><a href=#makefiles-as-operators>Makefiles as operators</a></li></ul></li></ul></li></ul></nav></aside></main></body></html>