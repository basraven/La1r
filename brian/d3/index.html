<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke-width: 1.5px;
}

</style>
<body>
<!-- <script src="./d3.v3.min.js"></script> -->
<script src="https://d3js.org/d3.v3.min.js"></script>
<script>

var width = 960,
    height = 500,
    fociDist = 4;

var fill = d3.scale.category10();

var nodes = [],
    foci = [{x: 150, y: 150}, {x: 350, y: 250}, {x: 700, y: 400}];

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
          g = svg.append("g");

// then, create the zoom behvavior
var zoom = d3.behavior.zoom()
// only scale up, e.g. between 1x and 50x
.scaleExtent([1, 50])
.on("zoom", function() {
    // the "zoom" event populates d3.event with an object that has
    // a "translate" property (a 2-element Array in the form [x, y])
    // and a numeric "scale" property
    var e = d3.event,
        // now, constrain the x and y components of the translation by the
        // dimensions of the viewport
        tx = Math.min(0, Math.max(e.translate[0], width - width * e.scale)),
        ty = Math.min(0, Math.max(e.translate[1], height - height * e.scale));
    // then, update the zoom behavior's internal translation, so that
    // it knows how to properly manipulate it on the next movement
    zoom.translate([tx, ty]);
    // and finally, update the <g> element's transform attribute with the
    // correct translation and scale (in reverse order)
    g.attr("transform", [
    "translate(" + [tx, ty] + ")",
    "scale(" + e.scale + ")"
    ].join(" "));
});

// then, call the zoom behavior on the svg element, which will add
// all of the necessary mouse and touch event handlers.
// remember that if you call this on the <g> element, the even handlers
// will only trigger when the mouse or touch cursor intersects with the
// <g> elements' children!
svg.call(zoom);


var force = d3.layout.force()
    .nodes(nodes)
    .links([])
    .charge(-1)
    .gravity(0)
    .size([width, height])
    .on("tick", tick);

var node = svg.selectAll("circle");

// function nearFoci(x, y){
//     var near = false;
//     foci.forEach((focus) => {
//         if( (x + fociDist)  )
//     })
// }

function tick(e) {
  var k = .1 * e.alpha;

  // Push nodes toward their designated focus.
  nodes.forEach(function(o, i) {
    o.y += (foci[o.id].y - o.y) * k;
    o.x += (foci[o.id].x - o.x) * k;
  });

  node
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

setInterval(function(){
  nodes.push({id: ~~(Math.random() * foci.length)});
  force.start();

  node = node.data(nodes);

  node.enter().append("circle")
      .attr("class", "node")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", 2)
      .style("fill", function(d) { return fill(d.id); })
      .style("stroke", function(d) { return d3.rgb(fill(d.id)).darker(2); })
      .call(force.drag);
    // node.forEach((o, i) => {
    //     o.forEach((j,k) => {
    //         console.log('j') //TODO: add if near a center
    //         if(j.cx.animVal.value > 300){
    //             j.remove()
    //         }
    //     })
    // })
}, 500);

</script>